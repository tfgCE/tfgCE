#pragma once

// these are all includes, definitions, everything

#include "..\meshGenAdvancedShapes.h"

#include "..\meshGenShapeUtils.h"

#include "..\..\meshGenGenerationContext.h"
#include "..\..\meshGenCreateCollisionInfo.h"
#include "..\..\meshGenUtils.h"
#include "..\..\meshGenElementModifier.h"
#include "..\..\meshGenEdgeDef.h"
#include "..\..\meshGenNodeDef.h"
#include "..\..\meshGenSubStepDef.h"
#include "..\..\meshGenSurfaceDef.h"
#include "..\..\meshGenValueDef.h"
#include "..\..\customData\meshGenEdge.h"
#include "..\..\customData\meshGenEdgeRef.h"
#include "..\..\customData\meshGenRefLookup.h"
#include "..\..\customData\meshGenSpline.h"
#include "..\..\customData\meshGenSplineRef.h"

#include "..\..\..\library\customLibraryDatas.h"
#include "..\..\..\library\customLibraryDataLookup.h"
#include "..\..\..\library\customLibraryDataLookup.inl"

#include "..\..\..\..\core\collision\model.h"
#include "..\..\..\..\core\mesh\mesh3d.h"
#include "..\..\..\..\core\mesh\socketDefinitionSet.h"
#include "..\..\..\..\core\mesh\builders\mesh3dBuilder_IPU.h"
#include "..\..\..\..\core\mesh\helpers\mesh3dHelper_bezierSurface.h"
#include "..\..\..\..\core\wheresMyPoint\wmp.h"

using namespace Framework;
using namespace MeshGeneration;
using namespace AdvancedShapes;

//

// everything is resolved in prepare_for_generation, so nothing can override_ default values
//	note:	variables marked with CACHED_ might be not safe to use before or after generation
//			and tbh it might be a little bit mess because of it as it disallows using more than one of them at the time
//			CACHED_ should be paired with mutable - in prepare_for_generation only those values should be modified
//			hence there are some copies, eg. csOnCurve -> csOnCurveToUse
//	todo:	it might be good idea to have arrays with instances for each generation allowing multithreaded generation
//			and recurency

class EdgesAndSurfacesData;
class EdgesAndSurfacesContext;

struct Node;
struct Edge;
struct Surface;
struct EdgeMesh;
struct SurfaceMesh;
struct GatheredEdge;

namespace PrepareForGenerationLevel
{
	enum Type
	{
		Resolve,
		BuildCrossSections,		// build all cross sections
		NodeLocation,			// mirror nodes, process node's "where's my point"
		AutoConvexPolygons,		// build convex hulls for polygons
		Resolve_AutoGenerated,
		EdgeCurves,				// calculate curves for edges (might be altered later)
		FlatNormals,			// calculates flat normals for nodes (note: unused so far!)
		AutoSmoothEdges,		// smoothes edges depending on auto smooth settings - this alters edges that are later used as altered,
								// both node and edge has to have parameters set, by default all nodes can be smoothed and none edge
		ExtrudeNormals,			// calculates extrude normals, used for surface extrusion when building surface mesh
		Surfaces,				// prepare bezier surfaces for surfaces
		EdgeMeshes,				// calculate stuff for edges and generate meshes used by edge meshes
		PlaceOnEdges,			// has to be after edge meshes (as uses them)
		Finish,
		MAX,
	};

	inline bool should_resolve_auto_generated(bool _autoGenerated, Type _level) { return (!_autoGenerated && _level == Resolve) || (_autoGenerated && _level == Resolve_AutoGenerated); }
};

struct Node
{
	struct Normal
	{
		Name surfaceGroup;
#ifdef AN_DEVELOPMENT
		tchar const * unsafeReason = nullptr;
#endif
		Vector3 normal = Vector3::zero;
		Normal() {}
		Normal(Name const & _surfaceGroup) : surfaceGroup(_surfaceGroup) {}
	};
	Name id;
	MeshGenParam<Vector3> locationFromVar;
	Vector3 locationAsLoaded = Vector3::zero;
	mutable Vector3 location = Vector3::zero;
	Optional<Vector3> normal; // as provided by user
	Name mirrorXOfId;
	Name mirrorYOfId;
	Name mirrorZOfId;
	Name collapseXOfId;
	Name addToId;
	NodeDef nodeDef;
	mutable CACHED_ Node const * mirrorXOf = nullptr;
	mutable CACHED_ Node const * mirrorYOf = nullptr;
	mutable CACHED_ Node const * mirrorZOf = nullptr;
	mutable CACHED_ Node const * collapseXOf = nullptr;
	mutable CACHED_ Node const * addTo = nullptr;
	mutable CACHED_ Array<Surface const *> inSurfaces;
	mutable CACHED_ Vector3 totalNormal; // total normal, from all surfaces
	mutable CACHED_ Array<Normal> flatNormals; // flat normals, from all surfaces per surface group. these are based only on nodes' locations - completely ignore edges
	mutable CACHED_ Array<Normal> extrudeNormals; // extrude normal, from all surfaces (per surface group), this is not normal as normal, it may have different length (non 1.0). it is used to extrude surfaces, edges by specific amount

	bool debugDraw = false;

	WheresMyPoint::ToolSet wmpToolSet;

	bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool prepare_for_generation(int _idx, EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;

	bool has_flat_normal(Name const & _surfaceGroup) const;
	bool has_extrude_normal(Name const & _surfaceGroup) const;
	Vector3 const * find_flat_normal(ElementInstance& _instance, Name const & _surfaceGroup) const;
	Vector3 const * find_extrude_normal(ElementInstance& _instance, Name const & _surfaceGroup) const;

	void build_normals(ElementInstance & _instance, 
		Array<Normal> & _normals,
		std::function<bool(Name const & _surfaceGroup)> _has_normal,
		std::function<Vector3(Surface const * _surface)> _calculate_normal,
		std::function<void(Plane & _plane)> _adjust_planes_for_normal_calculation,
		std::function<void(Vector3 & _normal)> _final_normal_normalisation) const;
};

struct Edge
{
	Name id;
	Name fromNodeId;
	Name toNodeId;
	Name atFromTowardsNodeId; // p1 will be based on this
	Name atToTowardsNodeId; // p2 will be based on this
	// if dirFromNode not provided, will work basically as towardsNode
	Name atFromUseDirFromNodeId; // p1 will be based on this
	Name atFromUseDirToNodeId; // p1 will be based on this
	Name atToUseDirFromNodeId; // p1 will be based on this
	Name atToUseDirToNodeId; // p1 will be based on this
	bool roundSeparationAtFrom = true;
	bool roundSeparationAtTo = true;
	bool useNormals = false; // use normals from nodes
	mutable EdgeDef edgeDef;
	Name mirrorOfId;
	mutable CACHED_ Edge const * mirrorOf = nullptr;
	mutable CACHED_ Node const * fromNode = nullptr;
	mutable CACHED_ Node const * toNode = nullptr;
	mutable CACHED_ Node const * atFromTowardsNode = nullptr;
	mutable CACHED_ Node const * atToTowardsNode = nullptr;
	mutable CACHED_ Node const * atFromUseDirFromNode = nullptr;
	mutable CACHED_ Node const * atFromUseDirToNode = nullptr;
	mutable CACHED_ Node const * atToUseDirFromNode = nullptr;
	mutable CACHED_ Node const * atToUseDirToNode = nullptr;
	MeshGenParam<Vector3> atFromDir;
	MeshGenParam<Vector3> atFromDirNeg; // negative
	MeshGenParam<Vector3> atFromNormal; // will be used to drop_using
	MeshGenParam<Vector3> atToDir;
	MeshGenParam<Vector3> atToDirNeg; // negative
	MeshGenParam<Vector3> atToNormal;
	/*
	Optional<Vector3> curveOffsetAtFrom; // for p1 (p1 = p0 + offset)
	Optional<Vector3> curveOffsetAtTo; // for p2 (p2 = p3 + offset)
	*/
	mutable CACHED_ BezierCurve<Vector3> curve; // calculated
	mutable CACHED_ Array<Surface const *> inSurfaces;

	bool debugDraw = false;

	bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool prepare_for_generation(EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;

	Node const * get_from_node(bool _reversed = false) const { return _reversed ? toNode : fromNode; }
	Node const * get_to_node(bool _reversed = false) const { return _reversed ? fromNode : toNode; }
	
	bool has_from_to(Name const& _node) const { return fromNodeId == _node || toNodeId == _node; }
	//

	struct Ref
	{
		Name id;
		mutable bool reversed = false; // only important to set for first edge, will be set in consequetive edges properly
		mutable CACHED_ Edge const * edge = nullptr;

		bool load_from_xml(IO::XML::Node const * _node);

		bool prepare_for_generation(EdgesAndSurfacesContext & _context) const;
	};
};

struct Surface
{
	bool isAutoGenerated = false;
	Name id;
	Array<Name> inSurfaceGroups; // allows to separate specific tools/functionality basing on surface group, all are in "invalid name" group too, which works as default
	BezierSurfaceCreationMethod::Type surfaceCreationMethod = BezierSurfaceCreationMethod::Roundly;
	SurfaceDef surfaceDef;
	Array<Name> nodesLoaded; // easier to build with just node names provided 
	Array<Edge::Ref> edgesLoaded;
	mutable CACHED_ Array<Edge::Ref> edges;
	mutable CACHED_ BezierSurface bezierSurface;

	bool debugDraw = false;

	bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool prepare_for_generation(EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;

	BezierCurve<Vector2> calculate_uv_curve_for(Edge const * _edge) const;

	Vector3 calculate_flat_normal_for(Node const * _node) const;
	Vector3 calculate_extrude_normal_for(Node const * _node) const;
	Vector3 calculate_normal_at_uv(Vector2 const & _uv) const;
	float calculate_size_for(Node const * _node) const;
	Plane calculate_plane_for(Node const * _node) const;
};

namespace EdgeMeshCorner
{
	enum Type
	{
		Cut,
		Sharp,
		Round,
		Weld
	};
};

namespace EdgeMeshEdgeStoreType
{
	enum Type
	{
		Location,
		Vector,
	};
};

struct EdgeMeshEdgeStoreOnCurve
{
	bool globalStore = false;
	Name asParameter;
	EdgeMeshEdgeStoreType::Type type = EdgeMeshEdgeStoreType::Location;
	Vector3 vector = Vector3::zero;
	ShapeUtils::PointOnCurve onCurve;
	bool applyScale = true;
	bool applyOffset = true;

	bool load_from_xml(IO::XML::Node const * _node);
};

struct EdgeSurfacesOnSides
{
	Surface const * surfaceOnLeft = nullptr; // on left - edge is in opposite direction
	Surface const * surfaceOnRight = nullptr; // on right - edge is in same direction
	BezierCurve<Vector2> surfaceOnLeftEdgeUV; // 0 starts where curve starts, 1 ends where curve ends
	BezierCurve<Vector2> surfaceOnRightEdgeUV; // (as above)

	void build(Edge::Ref const & _edgeRef, Name const & _useSurfaceGroup, Array<Surface*> const & _surfaces);
};

struct EdgeSurfacesContext
{
	Optional<Name> useSurfaceGroup;
	Optional<CustomData::EdgeNormalAlignment::Type> normalAlignment; // to override_ edge def
	ValueDef<Vector3> refPointForNormal;

	Name get_use_surface_group(EdgesAndSurfacesContext & _context, Name const & _base = Name::invalid()) const;
	CustomData::EdgeNormalAlignment::Type get_normal_alignment(EdgesAndSurfacesContext & _context, CustomData::EdgeNormalAlignment::Type const & _base = CustomData::EdgeNormalAlignment::AlignWithNormals) const;
	Vector3 get_ref_point_for_normal(EdgesAndSurfacesContext & _context, Vector3 const & _base = Vector3::zero) const;

	bool load_from_xml(IO::XML::Node const * _node);
};

struct EdgeMeshSkinningInfo
{
public:
	float pt = 0.0f;
	ValueDef<Name> boneA;
	ValueDef<Name> boneB;
	// weights and indexes are for actual use
	float boneAWeight = 1.0f;
	float boneBWeight = 0.0f;
	CACHED_ int boneAIdx = NONE;
	CACHED_ int boneBIdx = NONE;

	static bool load_from_xml(IO::XML::Node const * _node, Array<EdgeMeshSkinningInfo> & _skinning, tchar const * const _childName);

	static int compare(void const * _a, void const * _b);
	static float at_to_pt(float _at, float _lengthSoFar, float _thisLength);
	static EdgeMeshSkinningInfo blend(EdgeMeshSkinningInfo const & _a, EdgeMeshSkinningInfo const & _b, float _pt);

private:
	bool load_single_from_xml(IO::XML::Node const * _node);
};

struct EdgeMeshEdge
{
	Edge::Ref edgeRef;
	ValueDef<float> cornerRadius; // to override_ edge def or edge mesh
	ValueDef<bool> cutCorner; // to override_ edge def or edge mesh
	Array<ShapeUtils::CrossSectionOnCurve> csOnCurve; // to alter cross section from default
	mutable CACHED_ Array<ShapeUtils::CrossSectionOnCurve> csOnCurveToUseAll;
	mutable CACHED_ Array<ShapeUtils::CrossSectionOnCurve> csOnCurveToUseClamped; // without these outside of range
	mutable CACHED_ Array<ShapeUtils::CustomOnCurve> customOnCurveToUseAll;
	mutable CACHED_ Array<ShapeUtils::CustomOnCurve> customOnCurveToUseClamped; // without these outside of range
	Array<EdgeMeshEdgeStoreOnCurve> storeOnCurve;
	mutable CACHED_ Array<EdgeMeshEdgeStoreOnCurve> storeOnCurveToUse;

	// to be used only by corners (nodes!) - to allow matching with csOnCurve
	Name cornerCrossSectionId;
	ArrayStatic<Name, 8> cornerCrossSectionAltIds; // check CrossSectionOnCurve.altId
	ValueDef<float> cornerScaleFloat;
	ValueDef<Vector2> cornerScale;
	bool cornerWeld = false;
	
	float details = 1.0f; // increasing will increase number of subdivisions

	EdgeSurfacesContext surfacesContext;
	Array<EdgeMeshSkinningInfo> skinning;
	mutable CACHED_ Array<EdgeMeshSkinningInfo> skinningToUse; // filled with all missing and already oriented using reverse

	mutable CACHED_ Node const * node = nullptr; // taken from edge (this is "TO" node)
	mutable CACHED_ BezierCurve<Vector3> curve;
	mutable CACHED_ Range betweenCorners = Range(0.0f, 1.0f);
	mutable CACHED_ Optional<float> safeDistAt0;
	mutable CACHED_ Optional<float> safeDistAt1;
	//
	struct SharpCorner
	{
		// these are calculated from both curves (previous and next)
		Vector3 tangent;
		Vector3 normal;
		Vector3 right;
		Vector3 location;
		Vector2 scaleCrossSection = Vector2::one;
	};
	struct RoundCorner
	{
		// it only requires tangent and normal - tangent to calculate curve, normal to interpolate 
		BezierCurve<Vector3> curve;

		// we use curve window with four corners to create edge for round corners
		Range2 curveWindow;
		// four corners
		BezierCurve<Vector3> curveWindowCorners[4]; // LB, RB, LT, RT (ShapeUtils::Corner enum)

		Vector3 prevNormal; // before corner (this!)
		Vector3 nextNormal; // after corner (next!)

		void prepare(EdgeMesh const * _edgeMesh, EdgesAndSurfacesContext & _context, EdgeMeshEdge const * prev, EdgeMeshEdge const * edge);
	};
	mutable CACHED_ EdgeMeshCorner::Type cornerType = EdgeMeshCorner::Sharp; // at the end
	mutable CACHED_ SharpCorner sharpCorner; // for corner radius == 0.0
	mutable CACHED_ RoundCorner roundCorner;
	//
	mutable CACHED_ EdgeSurfacesOnSides surfacesOnSides;

	EdgeMeshEdge()
	{
		SET_EXTRA_DEBUG_INFO(cornerCrossSectionAltIds, TXT("EdgeMeshEdge.cornerCrossSectionAltIds"));
	}

	bool load_from_xml_as_edge(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool load_from_xml_as_node(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool prepare_for_generation(EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;
	
	// results might be not normalised against tangent!
	Vector3 calculate_normal_for(BezierCurve<Vector3> const & _curve, float _t, Vector3 const & _tangent, EdgeMesh const * _owner, EdgesAndSurfacesContext & _context) const;
	Vector3 calculate_normal_for(float _t, Vector3 const & _tangent, EdgeMesh const * _owner, EdgesAndSurfacesContext & _context) const;
	Matrix44 calculate_matrix_for(float _t, EdgeMesh const * _owner, EdgesAndSurfacesContext & _context) const;

	Meshes::VertexSkinningInfo calculate_skinning_info_for(BezierCurve<Vector3> const & _curve, float _t, EdgeMesh const * _owner, EdgesAndSurfacesContext & _context) const;
	Meshes::VertexSkinningInfo calculate_skinning_info_for(float _t, EdgeMesh const * _owner, EdgesAndSurfacesContext & _context) const;
};

struct EdgeMeshCrossSection
{
	Name id;
	Array<CustomData::Spline<Vector2>::Segment> segments;
};

struct SurfaceMesh
{
	bool isAutoGenerated = false;
	Name id;
	GenerationCondition generationCondition;
	UVDef uvDef;
	Optional<int> forceMaterialIdx;
	ValueDef<float> extrusion;
	ValueDef<float> extrusionU;
	ValueDef<Vector3> extrusionTowards;
	ValueDef<Vector3> extrusionNormal;
	ValueDef<float> extrusionFill; // at surface, how deep, where does it go
	ValueDef<bool> useNotExtrudedCurveForSubStep; // if not set will use it if fill is set
	Name extrusionSurfaceGroup;
	Array<Name> surfaceIds;
	mutable CACHED_ Array<Surface const *> surfaces;
	CreateCollisionInfo createMovementCollisionMesh; // will create mesh (that might be broken into convex hulls)
	CreateCollisionInfo createMovementCollisionBox; // will create box around mesh
	CreateCollisionInfo createPreciseCollisionMesh; // will create mesh
	CreateSpaceBlockerInfo createSpaceBlocker;
	bool noMesh = false;

	bool reversed = false;

	bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool prepare_for_generation(EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;
};

struct SurfaceMeshForEdge
: public SurfaceMesh
{
	typedef SurfaceMesh base;
	bool useEdgeEndPointsA = false;
	bool useEdgeEndPointsB = false;
	bool useOnePointAsCommon = false; // instead of doing centre or useCentrePointAsCommon
	ValueDef<float> tuckInwards = 0.0f;
	bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
};

struct EdgeMesh
{
	Name id;
	GenerationCondition generationCondition;
	ValueDef<Name> useEdgeRefId;
	ValueDef<Name> bone;
	mutable CACHED_ int boneIdx = NONE;
	EdgeSurfacesContext surfacesContext;
	CustomData::EdgeRef * ownEdgeRef = nullptr;
	mutable CACHED_ CustomData::EdgeRef const * useEdgeRef = nullptr; // this will be set in prepare (resolve level), if id is null, this is own
	struct UseElements
	{
		Array<RefCountObjectPtr<Element>> elements; // to be used instead of edge ref
		Name lengthParamName; // to write current length of the edge, before generation
		Name startMeshNodeName;
		Name endMeshNodeName;
		Name divMeshNodeName; // if none or not found we use substeps
		SubStepDef subStep;

		// checkpoints are to get data
		mutable Checkpoint checkpointStart;
		mutable Checkpoint checkpointEnd;
		
		mutable Optional<Transform> startMeshNodePlacement;
		mutable Optional<Transform> endMeshNodePlacement;
		mutable Optional<Transform> startToEndCorridor; // corridor starting at start mesh node, towards end mesh node
		mutable float startToEndCorridorLength; // corridor starting at start mesh node, towards end mesh node
		mutable Range2 window;

		bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
		bool prepare_for_game(Library* _library, LibraryPrepareContext& _pfgContext);
	};
	UseElements useElements;
	ValueDef<Vector2> scaleCrossSection = ValueDef<Vector2>(Vector2::one);
	ValueDef<float> scaleCrossSectionFloat = ValueDef<float>(-1.0f); // negative value is to be ignored - is it really necessary?
	ValueDef<Vector2> offsetCrossSection = ValueDef<Vector2>(Vector2::zero);
	ValueDef<float> cornerRadius; // to override_ edge def
	ValueDef<bool> cutCorner; // to override_ edge def
	ValueDef<bool> cornersOnlyIfPossible; // if set, only very corners are calculated - really useful for sharp edges to avoid extra polygons (requires no corner radius, no cut corners, no autocsoc, FORCES corners only
	ValueDef<float> shortenStart = ValueDef<float>(0.0f);
	ValueDef<float> shortenEnd = ValueDef<float>(0.0f);
	ValueDef<Name> autoCSOCid;
	int autoCSOClod = NONE;
	ValueDef<bool> allowCSOC;
	ValueDef<bool> blockCSOC;
	bool csocOnlyIfMoreDetailsAllowed = false;
	bool autoCSOCOnlyIfMoreDetailsAllowed = false;
	mutable Name useAutoCSOCid;
	bool moveCapStartByShorten = true; // those work separately from edgecap's move
	bool moveCapEndByShorten = true;
	Name storeCrossSectionVertexCountInVar;
	CreateCollisionInfo createMovementCollisionMesh; // will create mesh (that might be broken into convex hulls)
	CreateCollisionInfo createMovementCollisionBox; // will create box around mesh (whole mesh)
	CreateCollisionInfo createMovementCollisionBoxes; // will create boxes around each edge
	CreateCollisionInfo createPreciseCollisionBox; // will create box around mesh (whole mesh)
	CreateCollisionInfo createPreciseCollisionMesh; // will create mesh
	CreateCollisionInfo createPreciseCollisionBoxes; // will create boxes around each edge
	CreateSpaceBlockerInfo createSpaceBlocker;
	bool noMesh = false;

	bool debugDraw = false;

	WheresMyPoint::ToolSet wmpToolSet;

	Array<SurfaceMeshForEdge*> generateSurfaceMeshes; // using edges from this - this is kind of limited, as it should be used only for flat edge meshes
											   // as it calculates centre point and goes for each edge and builds triangle

	Array<EdgeMeshEdge*> edges;
	mutable CACHED_ Array<EdgeMeshEdge *> useEdges; // only non degenerated which makes lots of things easier
	mutable CACHED_ bool hasCrossSection = false; // if is ready to use cross sections (otherwise faulty or using elements)
	mutable CACHED_ bool loopedEdgeChain = false; // looped/closed edge chain (edges)
	mutable CACHED_ bool cornersOnly = false;
	mutable CACHED_ Array<EdgeMeshCrossSection*> crossSectionSegments;
	mutable CACHED_ Array<ShapeUtils::CrossSection> crossSections; // already scaled by edge mesh scale
	mutable CACHED_ CustomData::EdgeCap const * capStart = nullptr;
	mutable CACHED_ CustomData::EdgeCap const * capEnd = nullptr;
	mutable CACHED_ Array<Vector3> edgeEndPointsA;
	mutable CACHED_ Array<Vector3> edgeEndPointsB;
	mutable CACHED_ float capStartT = 0.0f;
	mutable CACHED_ float capEndT = 1.0f;

	~EdgeMesh();

	float get_corner_radius(EdgesAndSurfacesContext & _context) const;
	bool get_cut_corner(EdgesAndSurfacesContext & _context) const;
	
	void clear_cross_sections() const;

	bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool prepare_for_game(Library* _library, LibraryPrepareContext& _pfgContext);

	bool prepare_for_generation(int _idx, EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;
	static bool prepare_all_for_generation(EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level);
};

namespace EdgeMeshPlaceAlignment
{
	enum Type
	{
		Start,
		Centre,
		End,
	};
};

struct EdgePlaceOnEdgeAt
{
	EdgeMeshPlaceAlignment::Type alignment = EdgeMeshPlaceAlignment::Centre; // this is used when spacing disallows filling whole range
	bool adjustStartAndEndElements = true; // if we will occupy less space, move start and end elements closer
	ValueDef<Range> pt = ValueDef<Range>(Range(0.0f, 1.0f)); // if that's single value, it will be just one mesh
	ValueDef<float> spacing;
	ValueDef<RangeInt> count;
	ValueDef<bool> coverWholeLength; // will try to cover whole length, trying to keep minimal spacing
	ValueDef<bool> atLeastOne; // have at least one, if can't be on ends and spacing is too small, just add in the middle
	ValueDef<bool> skipEnds; // skip placing on ends
	ValueDef<bool> dontAddLastOne; // skip the last one
	ValueDef<bool> dontAddFirstOne; // skip the first one
	ValueDef<bool> updateElementSize; //when covering whole length it may either update element size or spacing

	bool load_from_xml(IO::XML::Node const * _node);
};

struct EdgePlaceOnEdge;

struct EdgePlaceOnEdgeEdge
{
	Edge::Ref edgeRef;
	Name asInEdgeMesh; // to get betweenCorners
	mutable CACHED_ EdgeMesh const * edgeMesh = nullptr;
	mutable CACHED_ EdgeMeshEdge const * edgeMeshEdge = nullptr;
	mutable CACHED_ float cornerScaleFloat = 1.0f;
	mutable CACHED_ Vector2 cornerScale = Vector2::one;

	EdgeSurfacesContext surfacesContext;
	mutable CACHED_ EdgeSurfacesOnSides surfacesOnSides;

	mutable CACHED_ BezierCurve<Vector3> curve; // got from edge
	mutable CACHED_ Range curveRange; // from between corners?
	mutable CACHED_ float curveLength;
	bool useNormals = false;
	mutable CACHED_ Vector3 startNormal;
	mutable CACHED_ Vector3 endNormal;

	Array<EdgePlaceOnEdgeAt> ats; // if empty, it takes from main ats

	bool load_from_xml(IO::XML::Node const * _node);
	bool prepare_for_generation(EdgePlaceOnEdge const * _owner, EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;
};

struct EdgePlaceOnEdgeElements
{
	ValueDef<float> size = ValueDef<float>(0.0f); // optional size, will add to min spacing to determine how much objects can fit
	Array<RefCountObjectPtr<Element>> elements;

	// these are used to set parameters for each element, this is based on how it was placed
	// Those values may be set directly or updated when placement requires stretching to cover whole thing
	Name elementsSizeParamName;
	Name spacingParamName;
	Name firstElementParamName;
	Name lastElementParamName;

	bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool prepare_for_game(Library* _library, LibraryPrepareContext& _pfgContext);
#ifdef AN_DEVELOPMENT
	void for_included_mesh_generators(std::function<void(MeshGenerator*)> _do) const;
#endif
};

struct EdgePlaceOnEdge
{
	Name id;

	GenerationCondition generationCondition;
	
	EdgeSurfacesContext surfacesContext;

	Name onEdgeMesh; // to get auto (with corners!) if we do not use this, we have to manually add edges (although we can base on onEdgeMesh per edge, but we won't get corners)
	Array<Name> notOnEdges; // if using onEdgeMesh, will skip provided edges (+ corners that they participate in)
	Array<EdgePlaceOnEdgeEdge> edges; // at which edge(s) it should be placed
	mutable CACHED_ EdgeMesh const * edgeMesh = nullptr;
	mutable CACHED_ Array<EdgePlaceOnEdgeEdge> useEdges; // actual edges (copy of edges or auto via onEdgeMesh)

	ValueDef<Transform> placement; // uses scale od edges

	Array<EdgePlaceOnEdgeAt> ats; // if asInEdgeMesh, this will be for whole length (will ignore ats), otherwise "per edge"

	EdgePlaceOnEdgeElements atStartElements;
	EdgePlaceOnEdgeElements mainElements;
	EdgePlaceOnEdgeElements atEndElements;

	Axis::Type alongDirAxis = Axis::Y; // by default along is y axis, for z: x is kept, for x: z is kept

	bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool prepare_for_game(Library* _library, LibraryPrepareContext& _pfgContext);
	bool prepare_for_generation(EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;
#ifdef AN_DEVELOPMENT
	void for_included_mesh_generators(std::function<void(MeshGenerator*)> _do) const;
#endif

	int calculate_count_for(EdgesAndSurfacesContext & _context, EdgePlaceOnEdgeAt const * _at, float _curveLengthAvailable, bool _looped, tchar const * _edgeId, OUT_ EdgeMeshPlaceAlignment::Type & _alignment, OUT_ float & _spacing, OUT_ bool & _skipEnds, OUT_ bool & _atLeastOne) const;

	EdgePlaceOnEdgeEdge* find_edge_among_use_edges(REF_ float & _atDist, OUT_ float & _localT);
};

class EdgesAndSurfacesData;

struct Poly
{
	Name nodeAId, nodeBId, nodeCId, nodeDId;
	ValueDef<Name> bone;
	ValueDef<Vector3> offset;
	mutable CACHED_ int boneIdx = NONE;
	mutable CACHED_ Vector3 offsetAct = Vector3::zero;
	mutable CACHED_ Node const * nodeA = nullptr;
	mutable CACHED_ Node const * nodeB = nullptr;
	mutable CACHED_ Node const * nodeC = nullptr;
	mutable CACHED_ Node const * nodeD = nullptr;

	bool load_from_xml(IO::XML::Node const * _node);
	bool prepare_for_generation(EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;
};

struct AutoConvex
{
	struct Triangle
	{
		Name nodeA, nodeB, nodeC; // nodes
		Triangle() {}
		Triangle(Name const& _nodeA, Name const& _nodeB, Name const& _nodeC) : nodeA(_nodeA), nodeB(_nodeB), nodeC(_nodeC) {}

		bool has(Name const& n) const { return nodeA == n || nodeB == n || nodeC == n; }
	};

	enum Type
	{
		No,
		All,
		Chosen,
	};
	Type autoConvex = Type::No;
	bool autoConvexNoMirrorX = false;
	bool autoConvexGenerateSurfaces = false; // if there are available edges
	bool autoConvexGenerateSurfacesOnly = false; // no polygons generated
	BezierSurfaceCreationMethod::Type surfaceCreationMethod = BezierSurfaceCreationMethod::Roundly; // not loaded though
	UVDef surfacesUVDef;
	Array<Name> autoConvexNodes; // all these nodes will be used to create convex shape
	Array<Name> excludeAutoConvexNodes; // all but these
	List<Array<Name>> excludeAutoConvexNodeSets; // if all points of a triangle are in one set, triangle is discarded

	mutable Array<Triangle> triangles;

	bool load_from_xml(IO::XML::Node const* _node);

	bool prepare_for_generation(EdgesAndSurfacesContext& _context, PrepareForGenerationLevel::Type _level) const;
};

struct Polygons
{
	Name id;
	GenerationCondition generationCondition;
	Array<Poly> polygons;
	UVDef uvDef;
	Optional<int> forceMaterialIdx;
	AutoConvex autoConvex;

	CreateCollisionInfo createMovementCollisionMesh; // will create mesh (that might be broken into convex hulls)
	CreateCollisionInfo createMovementCollisionBox; // will create box around mesh (whole mesh)
	CreateCollisionInfo createPreciseCollisionMesh; // will create mesh
	CreateCollisionInfo createPreciseCollisionBox; // will create box around mesh (whole mesh)
	CreateSpaceBlockerInfo createSpaceBlocker;

	bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	bool prepare_for_generation(EdgesAndSurfacesContext & _context, PrepareForGenerationLevel::Type _level) const;
};

struct GenerateSubElement
: public SoftPooledObject<GenerateSubElement>
{
	typedef SoftPooledObject<GenerateSubElement> base;
public:
	Element const * element = nullptr;
	Transform placement = Transform::identity;
	Vector3 scale = Vector3::one;
	SimpleVariableStorage parameters;

	static GenerateSubElement* get_one(Element const * _element, Transform const & _placement, Vector3 const & _scale = Vector3::one);

private: friend class SoftPooledObject < GenerateSubElement >;
	override_ void on_release();
};

class EdgesAndSurfacesContext
: public WheresMyPoint::IOwner
{
	FAST_CAST_DECLARE(EdgesAndSurfacesContext);
	FAST_CAST_BASE(WheresMyPoint::IOwner);
	FAST_CAST_END();

	typedef WheresMyPoint::IOwner base;
public:
	EdgesAndSurfacesContext(GenerationContext & _generationContext, ElementInstance & _elementInstance, EdgesAndSurfacesData const * _edgesAndSurfaces, ::Meshes::Builders::IPU & _ipu);
	~EdgesAndSurfacesContext();

	GenerationContext & access_generation_context() { return generationContext; }
	ElementInstance & access_element_instance() { return elementInstance; }
	EdgesAndSurfacesData const * get_edges_and_surfaces_data() const { return edgesAndSurfaces; }
	::Meshes::Builders::IPU & access_ipu() { return ipu; }

	void add_sub_element_to_generate(GenerateSubElement * _generateSubElement) { generateSubElements.push_back(_generateSubElement); }

	bool generate_all_sub_elements(GenerationContext & _context, ElementInstance & _instance);

public: // WheresMyPoint::IOwner
	override_ bool get_point_for_wheres_my_point(Name const & _byName, OUT_ Vector3 & _point) const;
	override_ bool store_value_for_wheres_my_point(Name const & _byName, WheresMyPoint::Value const & _value);
	override_ bool store_convert_value_for_wheres_my_point(Name const& _byName, TypeId _to);
	override_ bool rename_value_forwheres_my_point(Name const& _from, Name const& _to);
	override_ bool restore_value_for_wheres_my_point(Name const & _byName, OUT_ WheresMyPoint::Value & _value) const;
	override_ bool store_global_value_for_wheres_my_point(Name const & _byName, WheresMyPoint::Value const & _value);
	override_ bool restore_global_value_for_wheres_my_point(Name const & _byName, OUT_ WheresMyPoint::Value & _value) const;

	override_ IOwner* get_wmp_owner() { return &elementInstance; }

private:
	GenerationContext & generationContext;
	ElementInstance & elementInstance;
	EdgesAndSurfacesData const * edgesAndSurfaces;
	::Meshes::Builders::IPU & ipu;
	Array<GenerateSubElement*> generateSubElements;
};

class EdgesAndSurfacesData
: public ElementShapeData
{
	FAST_CAST_DECLARE(EdgesAndSurfacesData);
	FAST_CAST_BASE(ElementShapeData);
	FAST_CAST_END();

	typedef ElementShapeData base;

public:
	override_ bool load_from_xml(IO::XML::Node const * _node, LibraryLoadingContext & _lc);
	override_ bool prepare_for_game(Library* _library, LibraryPrepareContext& _pfgContext);
#ifdef AN_DEVELOPMENT
	override_ void for_included_mesh_generators(std::function<void(MeshGenerator*)> _do) const;
#endif

	override_ bool is_stateless() const { return false; }

public:
	EdgesAndSurfacesData();
	~EdgesAndSurfacesData();

	bool prepare_for_generation(EdgesAndSurfacesContext & _context) const;

	bool process(EdgesAndSurfacesContext & _context) const;
	void process_edge_meshes(EdgesAndSurfacesContext & _context) const;
	void process_surface_meshes(EdgesAndSurfacesContext & _context) const;
	void process_place_mesh_on_edges(EdgesAndSurfacesContext & _context) const;
	void process_polygons(EdgesAndSurfacesContext & _context) const;
	
private:
	bool generate_surface_mesh(EdgesAndSurfacesContext & _context, SurfaceMesh const * surfaceMesh, SurfaceDef const & surfaceDef, BezierSurfaceCreationMethod::Type surfaceCreationMethod, ArrayStatic<GatheredEdge,4> const & gatheredEdges, ArrayStatic<GatheredEdge,4> const * gatheredEdgesForSubStep = nullptr) const;

public:
	CustomData::RefLookup<CustomData::EdgeRef> edgeRefs;

	CreateCollisionInfo createMovementCollisionMesh; // will create mesh (that might be broken into convex hulls)
	CreateCollisionInfo createMovementCollisionBox; // will create box around mesh
	CreateCollisionInfo createPreciseCollisionMesh; // will create mesh
	CreateCollisionInfo createPreciseCollisionBox; // will create box around mesh
	CreateSpaceBlockerInfo createSpaceBlocker;
	bool noMesh = false;
	bool ignoreForCollision = false;

	bool debugDrawNodes = false;
	bool debugDrawEdges = false;
	bool debugDrawSurfaces = false;

	float debugDrawNodesTextScale = 1.0f;
	float debugDrawEdgesTextScale = 1.0f;
	float debugDrawSurfacesTextScale = 1.0f;

	// data shared by "generate meshes"
	Array<Node*> nodes;
	Array<Edge*> edges;
	mutable Array<Surface*> surfaces;
	// generate meshes
	Array<EdgeMesh*> edgeMeshes;
	mutable Array<SurfaceMesh*> surfaceMeshes;
	Array<EdgePlaceOnEdge*> placeOnEdges;
	Array<Polygons*> polygons;

	// sub elements
	Array<RefCountObjectPtr<Element>> elements;

	mutable int autoConvexId = 0;

	Node const * find_node(Name const & _id) const;
	Node const * find_node(Vector3 const & _loc) const;
	Edge const * find_edge(Name const & _id) const;
	Edge const * find_edge_for_nodes(Name const & _nodeA, Name const& _nodeB, OPTIONAL_ OUT_ bool* _reversed = nullptr, bool _quiet = false) const;
	Surface const * find_surface(Name const & _id) const;
	EdgeMesh const * find_edge_mesh(Name const & _id) const;

	void place_elements_at(EdgePlaceOnEdge const * _placeOnEdge, EdgePlaceOnEdgeEdge const * _edge, float _t, bool _forward, EdgesAndSurfacesContext & _context, EdgePlaceOnEdgeElements const & _elements, float _placedOnEdgeElementSize = -1.0f, float _placedOnEdgeSpacing = -1.0f, int _onEdgeIndex = NONE, int _onEdgeCount = 0) const;

	static Vector3 calculate_normal_for(ElementInstance& _instance, BezierCurve<Vector3> const & _curve, float _t, Vector3 const & _tangent, CustomData::EdgeNormalAlignment::Type _normalAlignment, EdgeSurfacesOnSides const & _surfacesOnSides, Vector3 const & _refPoint);
};

//

ElementShapeData* AdvancedShapes::create_edges_and_surfaces_data()
{
	return new EdgesAndSurfacesData();
}

//

TYPE_AS_CHAR(GenerateSubElement);
